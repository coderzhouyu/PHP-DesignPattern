## 策略模式
定义算法簇，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## 代码文件释义
* ducknofly 客户还没有提出需要鸭子类有 fly 这个行为。
* duckfly1  使用 Trait 方式实现 fly 并且在鸭子子类中复用。【不灵活-针对实现 fly 编程】
* duckfly2  使用 interface fly 的方式，提供一组接口实现类来扩展鸭子类。【个人理解-在鸭子类中留一个接口，fly 的行为都面向此接口编程】

## 个人理解和对代码的理解解释
比如鸭子类中先给定一个 fly 方法。
因为这个方法在不同的鸭子子类【绿头鸭，红头鸭，橡皮鸭，火箭鸭】中表现行为不一样（有的翅膀飞，有个飘来飘去，有的不会飞）
如果具体行为都定义在鸭子子类中代码会出现大量重复。
即便是运用 trait 这样的方式去扩展也不利于 fly 行为的灵活变化和扩展。比如：鸭子类子类在执行过程中变化 fly 行为。

所以将 fly 方法通过引入一个接口类来实现，所有的具体 fly 行为都在接口的实现类中来实现。
在鸭子类的 fly 方法中，通过传入实现 fly 接口类的实现类实例对象来指定鸭子类的子类具体的 fly 行为。
通过更改传入的 fly 接口类的实现类实例来改变当前鸭子子类的 fly 行为。